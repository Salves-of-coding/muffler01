# 1316 그룹 단어 체커
"""
aabbbccb = 그룹 단어 x
kin = 그룹 단어
ccazzzzbb = 그룹 단어
즉, 앞선 나온 문자가 뒤에 또 나오지 않으면 그룹 단어이다.

첫째 줄에 단어의 개수 N이 들어온다.
단어는 알파벳 소문자로만 되어있고 중복되지 않는다.

3
happy
new
year
aaba

접근법
알파벳이 사용된 이력이 있는지 체크하는 리스트와 가장 마지막으로 사용된 알파벳을 저장하는 문자형 변수가 필요하다.
이를 이용하면 다음같은 알고리즘을 만들 수 있다.
1. 알파벳이 사용된 이력이 없다면, 체크리스트에 포함한다. 이후 가장 마지막으로 사용한 알파벳으로 저장한다.
2. 가장 마지막으로 사용한 알파벳과 같다면, 패스한다. (앞선 문자와 같은 문자이다.)
3. 가장 마지막으로 사용한 알파벳과 다르다면, 패스한다. (앞선 문자와 다른 문자이다.)
4. 단, 가장 마지막으로 사용한 알파벳과 다르면서 (and) 알파벳이 사용된 이력이 있다면 이 단어는 그룹 단어가 아니다.

1. last = ''으로 마지막으로 사용한 알파벳을 저장할 공간을 만든다.
2. cnt = 0은 그룹 단어가 아닌 단어의 개수이다.
- for
    3. word = input()으로 단어를 입력받고, check = []로 알파벳의 사용이력을 저장하는 공간을 만들어 준다.
    - if
        4. 알파벳 사용이력 x, check에 포함, last에 저장
    - elif
        5. 알파벳 == last라면, 같은 문자이므로 pass
    - elif
        6. 알파벳 != last and check에 포함이라면, 그룹 단어가 아니므로 cnt += 1
        (단, abcabc와 같이 cnt가 2번 올라가는 단어도 있으므로, break문으로 빠져나온다.)
7. print(n-cnt)로 n은 입력받은 단어의 개수, cnt은 그룹 단어가 아닌 단어의 개수이다.

숙지가 필요한 항목
1. 논리회로 구현
2. 질문 게시판을 적극적으로 활용하자.
3. 코드는 참고용이다. 그대로 배끼는 것에는 의미가 없다.
4. break문으로 반례를 막자.
"""


n = int(input())
last = ''
cnt = 0

for _ in range(n):
    word = input()
    check = []
    for i in word:
        if i not in check:
            check.append(i)
            last = i
        elif i == last:
            pass
        elif i != last and i in check:
            cnt += 1
            break

print(n - cnt)